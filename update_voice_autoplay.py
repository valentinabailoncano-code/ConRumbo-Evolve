from pathlib import Path

path = Path('frontend/script.js')
text = path.read_text(encoding='utf-8')

# Add new properties in constructor
needle = "        this.activeUtterance = null;\n\n        if (!this.synthesis) {"
insert = "        this.voiceRate = 0.72;\n        this.voicePitch = 0.98;\n        this.autoAdvanceDelayMs = 6000;\n\n        this.activeUtterance = null;\n\n        if (!this.synthesis) {"
if needle not in text:
    raise SystemExit('constructor anchor missing')
text = text.replace(needle, insert, 1)

# Update translations speakCompletion
text = text.replace(
"                speakCompletion: 'Protocolo completado. Has realizado todos los pasos correctamente.',",
"                speakCompletion: 'Hemos llegado al final del protocolo. Si necesitas repetir alg\u00FAn paso pulsa repetir o p\u00EDdeme que lo repita. Cuando quieras comenzar otro protocolo selecciona nueva emergencia.',",
1)
text = text.replace(
"                speakCompletion: 'Protocol completed. You followed every step correctly.',",
"                speakCompletion: 'We have reached the end of the protocol. If you need to review a step press repeat or ask me to repeat it. When you are ready for a new protocol choose start new emergency.',",
1)

# Replace getVoiceForLanguage block with enhanced scoring
old = text[text.index('    getVoiceForLanguage(language) {'):text.index('    setupDOM() {')]
new_get_voice = "    getVoiceForLanguage(language) {\n        if (!this.voices.length) return null;\n\n        const preferredLangs = language === 'es'\n            ? ['es-es', 'es_es', 'es-mx', 'es-419', 'es', 'spa']\n            : ['en-us', 'en_us', 'en-gb', 'en_gb', 'en-au', 'en', 'eng'];\n        const preferredNames = language === 'es'\n            ? ['google espa', 'google us espa', 'google español', 'microsoft sabina', 'microsoft helena', 'microsoft laura', 'microsoft pablo']\n            : ['google us english', 'google uk english', 'google english', 'microsoft aria', 'microsoft zira', 'microsoft guy', 'microsoft ava'];\n\n        const scored = this.voices\n            .map((voice) => {\n                const lang = (voice.lang || '').toLowerCase();\n                const name = (voice.name || '').toLowerCase();\n                let score = 0;\n\n                preferredLangs.forEach((target, index) => {\n                    const weight = 50 - index * 6;\n                    if (lang === target) score += weight + 25;\n                    if (lang.startsWith(target)) score += weight + 12;\n                    if (lang.includes(target)) score += weight;\n                });\n\n                preferredNames.forEach((pattern, index) => {\n                    const weight = 60 - index * 8;\n                    if (name.includes(pattern)) score += weight;\n                });\n\n                if (name.includes('neural')) score += 8;\n                if (name.includes('natural')) score += 6;\n                if (name.includes('premium')) score += 4;\n\n                return { voice, score };\n            })\n            .filter((item) => item.score > 0)\n            .sort((a, b) => b.score - a.score);\n\n        if (scored.length) {\n            return scored[0].voice;\n        }\n\n        const fallbackPrefix = language === 'es' ? 'es' : 'en';\n        return this.voices.find((voice) => (voice.lang || '').toLowerCase().startsWith(fallbackPrefix)) || this.voices[0];\n    }\n\n"
text = text.replace(old, new_get_voice)

# Update advanceStep, showStep, repeatCurrentStep, completeProtocol, cancelActiveSpeech/speak
text = text.replace(
"    async advanceStep(autoTriggered = false) {\n        if (!this.currentProtocol || this.isAdvancing) return;\n        this.isAdvancing = true;\n\n        try {\n            const response = await fetch(`${this.apiBase}/next_step`, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    protocol_id: this.currentProtocol.id,\n                    current_step: this.currentStep,\n                    session_id: this.sessionId\n                })\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP error ${response.status}`);\n            }\n\n            const result = await response.json();\n\n            if (result.done) {\n                this.completeProtocol(autoTriggered);\n            } else {\n                this.currentStep = result.step_index;\n                this.showStep(result.step, result.step_index, result.total_steps, this.autoPlay);\n            }\n        } catch (error) {\n            console.error('Error al avanzar paso:', error);\n            this.updateStatus('statusAdvanceError');\n        } finally {\n            this.isAdvancing = false;\n        }\n    }\n\n    showStep(stepText, stepIndex, totalSteps, autoAdvance = false) {\n        this.elements.currentStep.textContent = stepText;\n        this.elements.stepCounter.textContent = `${this.config.language === 'es' ? 'Paso' : 'Step'} ${stepIndex + 1} ${this.config.language === 'es' ? 'de' : 'of'} ${totalSteps}`;\n        const shouldAutoAdvance = autoAdvance && this.autoPlay;\n        this.speak(stepText, {\n            onEnd: () => {\n                if (shouldAutoAdvance && this.autoPlay) {\n                    this.advanceStep(true);\n                }\n            },\n        });\n        this.vibrate(200);\n    }\n\n    repeatCurrentStep() {\n        if (!this.currentProtocol || this.currentStep < 0) return;\n        this.cancelActiveSpeech(true);\n        const stepText = this.currentProtocol.steps[this.currentStep];\n        this.speak(stepText, {\n            onEnd: () => {\n                if (this.autoPlay) {\n                    this.advanceStep(true);\n                }\n            },\n        });\n        this.vibrate(100);\n    }\n\n    completeProtocol() {\n        const finish = () => {\n            this.autoPlay = false;\n            setTimeout(() => {\n                this.showScreen('completion');\n            }, 800);\n        };\n        this.speak(this.t('speakCompletion'), { onEnd: finish });\n        this.vibrate([200, 100, 200]);\n    }\n\n    cancelActiveSpeech(skipCallback = false) {\n        if (this.activeUtterance) {\n            if (skipCallback) {\n                this.activeUtterance.onend = null;\n                this.activeUtterance.onerror = null;\n            }\n            this.activeUtterance = null;\n        }\n        if (this.synthesis) {\n            try {\n                this.synthesis.cancel();\n            } catch (error) {\n                console.warn('No se pudo cancelar la sintesis de voz', error);\n            }\n        }\n    }\n\n    speak(text, options = {}) {\n        const { onEnd } = options;\n\n        if (!this.config.voiceFeedbackEnabled || !this.synthesis) {\n            if (typeof onEnd === 'function') {\n                setTimeout(onEnd, 0);\n            }\n            return;\n        }\n\n        this.cancelActiveSpeech(true);\n\n        const utterance = new SpeechSynthesisUtterance(text);\n        utterance.lang = this.config.language === 'es' ? 'es-ES' : 'en-US';\n        const voice = this.getVoiceForLanguage(this.config.language);\n        if (voice) {\n            utterance.voice = voice;\n        }\n        utterance.rate = this.voiceRate;\n        utterance.pitch = this.voicePitch;\n        utterance.volume = 1;\n\n        if (typeof onEnd === 'function') {\n            utterance.onend = () => {\n                this.activeUtterance = null;\n                onEnd();\n            };\n            utterance.onerror = () => {\n                this.activeUtterance = null;\n                onEnd();\n            };\n        } else {\n            utterance.onend = () => {\n                this.activeUtterance = null;\n            };\n            utterance.onerror = () => {\n                this.activeUtterance = null;\n            };\n        }\n\n        this.activeUtterance = utterance;\n        this.synthesis.speak(utterance);\n    }\n"
text = text.replace(
"    async advanceStep(autoTriggered = false) {\n        if (!this.currentProtocol || this.isAdvancing) return;\n        this.isAdvancing = true;\n\n        try {\n            const response = await fetch(`${this.apiBase}/next_step`, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    protocol_id: this.currentProtocol.id,\n                    current_step: this.currentStep,\n                    session_id: this.sessionId\n                })\n            });\n\n            if (!response.ok) {\n                throw new Error(`HTTP error ${response.status}`);\n            }\n\n            const result = await response.json();\n\n            if (result.done) {\n                this.completeProtocol(autoTriggered);\n            } else {\n                this.currentStep = result.step_index;\n                this.showStep(result.step, result.step_index, result.total_steps, this.autoPlay);\n            }\n        } catch (error) {\n            console.error('Error al avanzar paso:', error);\n            this.updateStatus('statusAdvanceError');\n        } finally {\n            this.isAdvancing = false;\n        }\n    }\n\n    showStep(stepText, stepIndex, totalSteps, autoAdvance = false) {\n        this.elements.currentStep.textContent = stepText;\n        this.elements.stepCounter.textContent = `${this.config.language === 'es' ? 'Paso' : 'Step'} ${stepIndex + 1} ${this.config.language === 'es' ? 'de' : 'of'} ${totalSteps}`;\n        const shouldAutoAdvance = autoAdvance && this.autoPlay;\n        this.speak(stepText, {\n            onEnd: () => {\n                if (shouldAutoAdvance && this.autoPlay) {\n                    this.advanceStep(true);\n                }\n            },\n        });\n        this.vibrate(200);\n    }\n\n    repeatCurrentStep() {\n        if (!this.currentProtocol || this.currentStep < 0) return;\n        this.cancelActiveSpeech(true);\n        const stepText = this.currentProtocol.steps[this.currentStep];\n        this.speak(stepText, {\n            onEnd: () => {\n                if (this.autoPlay) {\n                    this.advanceStep(true);\n                }\n            },\n        });\n        this.vibrate(100);\n    }\n\n    completeProtocol() {\n        const finish = () => {\n            setTimeout(() => {\n                this.showScreen('completion');\n            }, 500);\n        };\n        this.speak(this.t('speakCompletion'), { onEnd: finish });\n        this.vibrate([200, 100, 200]);\n    }\n\n    cancelActiveSpeech(skipCallback = false) {\n        if (this.activeUtterance) {\n            if (skipCallback) {\n                this.activeUtterance.onend = null;\n                this.activeUtterance.onerror = null;\n            }\n            this.activeUtterance = null;\n        }\n        if (this.synthesis) {\n            try {\n                this.synthesis.cancel();\n            } catch (error) {\n                console.warn('No se pudo cancelar la sintesis de voz', error);\n            }\n        }\n    }\n\n    speak(text, options = {}) {\n        const { onEnd } = options;\n\n        if (!this.config.voiceFeedbackEnabled || !this.synthesis) {\n            if (typeof onEnd === 'function') {\n                setTimeout(onEnd, 0);\n            }\n            return;\n        }\n\n        this.cancelActiveSpeech(true);\n\n        const utterance = new SpeechSynthesisUtterance(text);\n        utterance.lang = this.config.language === 'es' ? 'es-ES' : 'en-US';\n        const voice = this.getVoiceForLanguage(this.config.language);\n        if (voice) {\n            utterance.voice = voice;\n        }\n        utterance.rate = 0.9;\n        utterance.pitch = 1;\n        utterance.volume = 1;\n\n        if (typeof onEnd === 'function') {\n            utterance.onend = () => {\n                this.activeUtterance = null;\n                onEnd();\n            };\n            utterance.onerror = () => {\n                this.activeUtterance = null;\n                onEnd();\n            };\n        } else {\n            utterance.onend = () => {\n                this.activeUtterance = null;\n            };\n            utterance.onerror = () => {\n                this.activeUtterance = null;\n            };\n        }\n\n        this.activeUtterance = utterance;\n        this.synthesis.speak(utterance);\n    }\n", new_get_voice + "    setupDOM() {\n")

# Ensure auto advance delay is applied by adding setTimeout inside showStep
text = text.replace(
"                if (shouldAutoAdvance && this.autoPlay) {\n                    this.advanceStep(true);\n                }\n",
"                if (shouldAutoAdvance && this.autoPlay) {\n                    setTimeout(() => {\n                        if (this.autoPlay) {\n                            this.advanceStep(true);\n                        }\n                    }, this.autoAdvanceDelayMs);\n                }\n")
text = text.replace(
"                if (this.autoPlay) {\n                    this.advanceStep(true);\n                }\n",
"                if (this.autoPlay) {\n                    setTimeout(() => {\n                        if (this.autoPlay) {\n                            this.advanceStep(true);\n                        }\n                    }, this.autoAdvanceDelayMs);\n                }\n")

Path('frontend/script.js').write_text(text, encoding='utf-8')
